\documentclass[12pt,a4paper]{article}

%Fonts and Chinese Words
\usepackage{fontspec}
\usepackage{xeCJK}
\setCJKmainfont[BoldFont=cwTeX Q Hei,ItalicFont=cwTeX Q Kai]
{cwTeX Q Ming}
\setCJKmonofont{cwTeX Q Hei}
\setCJKsansfont{cwTeX Q Hei}
\setmonofont{DejaVu Sans Mono}

\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt

%Japanese
\usepackage{ruby}
\setCJKfamilyfont{J}{HC Maru Gothic}

%Using Math Tools
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{relsize} %mathlarger

%Insert Code
\usepackage{verbatim}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor {mygreen}{rgb}{0,0.6,0}
\definecolor {mygray}{rgb}{0.5,0.5,0.5}
\definecolor {mymauve}{rgb}{0.58,0,0.82}

\lstset {
  backgroundcolor=\color{white},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=C++,
  morekeywords={*,...},
  numbers=left,
  numbersep=4pt,
  numberstyle=\scriptsize\ttfamily\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  stringstyle=\color{red},
  tabsize=4,
  xleftmargin=15pt,
  framexleftmargin=15pt,
  framexrightmargin=0pt,
  framexbottommargin=0pt,
  framextopmargin=0pt,
}

%HyperRef and link table of contents
\usepackage[linktoc=all]{hyperref}

%Set margins
\usepackage [left=2.0cm, right=2.0cm, top=2.0cm, bottom=2.0cm]{geometry}

%headings
\usepackage{fancyheadings}
\rhead{} %右邊
\chead{} %中央
\lhead{Computer Programming Lecture Note} %左邊
\pagestyle{fancy}

%Setting Title
\title{2017 Computer Programming Note}
\author{Harry Chang\\NTUEE}
\date{}

%Begin of document
\begin{document}
	\maketitle %Make title
	This is a lecture note of \textbf{Computer Programming} held by professor W.J. Liao, NTUEE. This note is mainly about \textbf{object oriented} computer programming in \texttt{C++}.\\
	Date: From Nov. 14, 2017 to.
	\tableofcontents %Make table of contents
	\clearpage
	
	\section{Concepts of Classes}
		\subsection{Basic Structure}
			\begin{lstlisting}
class myclass{
public:
	// member functions
	myclass(...); // constructor
	void function1(...);
	int function2(...);
private:
	// data member
	int variable1;
	double variable2;
};

myclass::myclass(...){...}
void myclass::function1(...){...}
int myclass::function2(...){...}
\end{lstlisting}
			While defining functions \textbf{outside} the scope of \texttt{class}, must add \texttt{myclass::} before function name.
		
		\subsection{Preprocess Wrapper}
			\begin{lstlisting}
#ifndef MYCLASS_H
#define MYCLASS_H
// myclass code
#endif\end{lstlisting}
			We can put the definition of \texttt{myclass} in \texttt{myclass.h}, and then define every function in \texttt{myclass.cpp}. Last, we can include \texttt{"myclass.h"} to use this class in other \texttt{.cpp} files. Because \textbf{linker} will link all those files together.
		\subsection{Constructor and Destructor}
			Constructor: Initialize object.
			
			\begin{lstlisting}
myclass(...);  // constructor
~myclass(...); // destructor
\end{lstlisting}
			\begin{description}
				\item[Type 1]
					\texttt{myclass()}\\
					\texttt{myclass jizz;}
				\item[Type 2]
					\texttt{myclass(int,int,int)}\\
					\texttt{myclass jizz(a,b,c);}
			\end{description}
			Constructor overloading is allowed. We can set several constructors at the same time.\\
			However, destructor overloading is \textbf{not} allowed!\\
			\texttt{\textcolor{blue}{static}} won't be destructed until the program ends.\\
			For \texttt{\textcolor{blue}{auto}} variables, last declared variable destroys first.\\
			
	\section{A Deeper Look in Class}	
		\subsection{Constant Object}
			In \texttt{myclass}:
			\begin{lstlisting}
void function1() const; // constant member function
const int variable; // constant data member
\end{lstlisting}
			Outside \texttt{myclass}:
			\begin{lstlisting}
myclass var1; // non-constant object
const myclass var2; // constant object
\end{lstlisting}
			When a member function doesn't have to change values in data member, we \textbf{must} declare these functions \texttt{\textcolor{blue}{const}} because if we accidentally put a \texttt{\textcolor{blue}{const}} object into a \texttt{\textcolor{blue}{non-const}} member function, it would result in a \texttt{\textcolor{mygray}{CE}}.\\\\
			Constant data member \textbf{must} be initialized using \texttt{member initializers}:
			\begin{lstlisting}
class myclass{
public:
	myclass(int _x, int _y, int _id)
	:x(_x), y(_y), id(_id){ // member initializers
		// empty
	}
private:
	int x, y;
	const int id; // we don't want to change this
};
\end{lstlisting}
			\textbf{Both} \texttt{\textcolor{blue}{non-const}} and \texttt{\textcolor{blue}{const}} data members can be initialized using \texttt{member initializers}.\\\\
			\texttt{Default copy constructor} copies each corresponding data member to initialize the new object:
			\begin{lstlisting}
myclass(const myclass &);
\end{lstlisting}
			
			
		\subsection{Friend}
			\begin{lstlisting}
class my_class{
	friend void my_friend(my_class &,int,int);
public:
	my_class():x(0),y(0){}
	void function(...);
private:
	int x,y;
};

void my_friend(my_class &c,int _x,int _y){
	c.x=_x; c.y=_y;
}
\end{lstlisting}
			\texttt{\textcolor{blue}{Friend}} functions aren't member functions, they have \textbf{granted the right to access} private data members.\\
			Advantage: \textbf{Enhance performance}.
	
		\subsection{Static Class Members}
			\begin{lstlisting}
class my_class{
public:
	my_class():x(0){count++;}
	void function1(...);
	static void set_count(int c){count=c;}// static member function
	static int get_count(){return count;} // static member function
private:
	int x;
	static int count; // static data
};
\end{lstlisting}
			There are two methods to access (in \texttt{main()}):\\
			\textbf{Method 1}
			\begin{lstlisting}
myclass a;
myclass b;
myclass::get_count();
myclass::set_count(5);
myclass::get_count();
\end{lstlisting}
	
	
	
		\subsection{\texttt{\textcolor{blue}{this}} Pointer}
			
			\begin{lstlisting}
my_class &set_x(int _x){x=_x; return *this;}
my_class &set_y(int _y){y=_y; return *this;}
\end{lstlisting}
			Use:
			\begin{lstlisting}
my_class a;
cin >> x >> y;
a.set_x(x).set_y(y); // using this pointer
\end{lstlisting}
			可以串接!
		
	\section{Operator Overloading}
		\subsection{Introduction}
			\texttt{a=a+b} v.s. \texttt{a=a.add(b)}\\
			Operators must be overloaded for that class.\\
			Exceptions (We can use them in our class without overloading.):
			\begin{itemize}
				\item Assignment operator: \texttt{=}
				\item Address operator: \texttt{\&}
				\item Comma operator: \texttt{,}
			\end{itemize}
			Overloading \texttt{?:} operator is \textbf{prohibited}!\\
			While overloading an operator with two different classes, we must overload it \textbf{globally}.
		
		
	\clearpage
			E.g.
			\begin{lstlisting}
class vec{ // vector class (not std::vector)
public:
	vec(){
		x=0;y=0;
	}
	vec(int _x,int _y){
		x=_x;y=_y;
	}
	void print(){
		printf("(%d,%d)\n",x,y);
	}
private:
	int x,y;
};

int main(){
	vec v1,v2(1,2);
	v1.print(); v2.print();
	return 0;
}
\end{lstlisting}
	
\end{document}
